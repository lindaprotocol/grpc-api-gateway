// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: proto/api.proto

/*
Package protocol is a reverse proxy.

It translates gRPC into RESTful JSON APIs for the Linda blockchain.
*/
package protocol

import (
	"context"
	"io"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
	"github.com/lindaprotocol/grpc-api-gateway/proto/core"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

// request_Wallet_GetAccount_0 handles POST /wallet/getaccount requests
// This endpoint expects a JSON body containing the Account message
func request_Wallet_GetAccount_0(ctx context.Context, marshaler runtime.Marshaler, client WalletClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq core.Account
	var metadata runtime.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.GetAccount(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err
}

// request_Wallet_GetAccount_1 handles GET /wallet/getaccount requests
// This endpoint expects query parameters matching the Account message fields
var filter_Wallet_GetAccount_1 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

func request_Wallet_GetAccount_1(ctx context.Context, marshaler runtime.Marshaler, client WalletClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq core.Account
	var metadata runtime.ServerMetadata

	if err := runtime.PopulateQueryParameters(&protoReq, req.URL.Query(), filter_Wallet_GetAccount_1); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.GetAccount(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err
}

// request_Wallet_CreateTransaction_0 handles POST /wallet/createtransaction
func request_Wallet_CreateTransaction_0(ctx context.Context, marshaler runtime.Marshaler, client WalletClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq core.TransferContract
	var metadata runtime.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateTransaction(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err
}

// request_Wallet_BroadcastTransaction_0 handles POST /wallet/broadcasttransaction
func request_Wallet_BroadcastTransaction_0(ctx context.Context, marshaler runtime.Marshaler, client WalletClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq core.Transaction
	var metadata runtime.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.BroadcastTransaction(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err
}

// ... (similar patterns for all other Wallet methods)

// RegisterWalletHandlerFromEndpoint registers the http handlers for service Wallet
// to a grpc-gateway mux, and dials to the provided endpoint.
func RegisterWalletHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterWalletHandler(ctx, mux, conn)
}

// RegisterWalletHandler registers the http handlers for service Wallet to "mux".
// The handlers forward requests to the grpc endpoint over the given connection.
func RegisterWalletHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterWalletHandlerClient(ctx, mux, NewWalletClient(conn))
}

// RegisterWalletHandlerClient registers the http handlers for service Wallet
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of WalletClient.
func RegisterWalletHandlerClient(ctx context.Context, mux *runtime.ServeMux, client WalletClient) error {
	// Register POST /wallet/getaccount
	mux.Handle("POST", pattern_Wallet_GetAccount_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_Wallet_GetAccount_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_Wallet_GetAccount_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// Register GET /wallet/getaccount
	mux.Handle("GET", pattern_Wallet_GetAccount_1, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_Wallet_GetAccount_1(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_Wallet_GetAccount_1(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// Register POST /wallet/createtransaction
	mux.Handle("POST", pattern_Wallet_CreateTransaction_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_Wallet_CreateTransaction_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_Wallet_CreateTransaction_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// ... (register all other Wallet endpoints)

	return nil
}

// Pattern definitions for Wallet service endpoints
var (
	pattern_Wallet_GetAccount_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"wallet", "getaccount"}, ""))
	pattern_Wallet_GetAccount_1 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"wallet", "getaccount"}, ""))
	pattern_Wallet_CreateTransaction_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"wallet", "createtransaction"}, ""))
	// ... (all other patterns)
)

// Forward response functions for Wallet endpoints
var (
	forward_Wallet_GetAccount_0 = runtime.ForwardResponseMessage
	forward_Wallet_GetAccount_1 = runtime.ForwardResponseMessage
	forward_Wallet_CreateTransaction_0 = runtime.ForwardResponseMessage
	// ... (all other forward functions)
)

// RegisterWalletSolidityHandlerFromEndpoint registers the http handlers for service WalletSolidity
func RegisterWalletSolidityHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()
	return RegisterWalletSolidityHandler(ctx, mux, conn)
}

// RegisterWalletSolidityHandler registers the http handlers for service WalletSolidity
func RegisterWalletSolidityHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterWalletSolidityHandlerClient(ctx, mux, NewWalletSolidityClient(conn))
}

// RegisterWalletSolidityHandlerClient registers the http handlers for service WalletSolidity
func RegisterWalletSolidityHandlerClient(ctx context.Context, mux *runtime.ServeMux, client WalletSolidityClient) error {
	// Register POST /walletsolidity/getaccount
	mux.Handle("POST", pattern_WalletSolidity_GetAccount_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_WalletSolidity_GetAccount_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_WalletSolidity_GetAccount_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// Register GET /walletsolidity/getaccount
	mux.Handle("GET", pattern_WalletSolidity_GetAccount_1, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_WalletSolidity_GetAccount_1(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_WalletSolidity_GetAccount_1(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// ... (register all other WalletSolidity endpoints)

	return nil
}

// Pattern definitions for WalletSolidity service endpoints
var (
	pattern_WalletSolidity_GetAccount_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"walletsolidity", "getaccount"}, ""))
	pattern_WalletSolidity_GetAccount_1 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"walletsolidity", "getaccount"}, ""))
	// ... (all other patterns)
)

// Forward response functions for WalletSolidity endpoints
var (
	forward_WalletSolidity_GetAccount_0 = runtime.ForwardResponseMessage
	forward_WalletSolidity_GetAccount_1 = runtime.ForwardResponseMessage
	// ... (all other forward functions)
)

// RegisterWalletExtensionHandlerFromEndpoint registers the http handlers for service WalletExtension
func RegisterWalletExtensionHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()
	return RegisterWalletExtensionHandler(ctx, mux, conn)
}

// RegisterWalletExtensionHandler registers the http handlers for service WalletExtension
func RegisterWalletExtensionHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterWalletExtensionHandlerClient(ctx, mux, NewWalletExtensionClient(conn))
}

// RegisterWalletExtensionHandlerClient registers the http handlers for service WalletExtension
func RegisterWalletExtensionHandlerClient(ctx context.Context, mux *runtime.ServeMux, client WalletExtensionClient) error {
	// Register POST /walletextension/gettransactionsfromthis
	mux.Handle("POST", pattern_WalletExtension_GetTransactionsFromThis_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_WalletExtension_GetTransactionsFromThis_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_WalletExtension_GetTransactionsFromThis_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// ... (register all other WalletExtension endpoints)

	return nil
}

// Pattern definitions for WalletExtension service endpoints
var (
	pattern_WalletExtension_GetTransactionsFromThis_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"walletextension", "gettransactionsfromthis"}, ""))
	// ... (all other patterns)
)

// Forward response functions for WalletExtension endpoints
var (
	forward_WalletExtension_GetTransactionsFromThis_0 = runtime.ForwardResponseMessage
	// ... (all other forward functions)
)

// RegisterDatabaseHandlerFromEndpoint registers the http handlers for service Database
func RegisterDatabaseHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()
	return RegisterDatabaseHandler(ctx, mux, conn)
}

// RegisterDatabaseHandler registers the http handlers for service Database
func RegisterDatabaseHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterDatabaseHandlerClient(ctx, mux, NewDatabaseClient(conn))
}

// RegisterDatabaseHandlerClient registers the http handlers for service Database
func RegisterDatabaseHandlerClient(ctx context.Context, mux *runtime.ServeMux, client DatabaseClient) error {
	// Register Database endpoints (no HTTP bindings in original proto, but can be added)
	return nil
}

// RegisterNetworkHandlerFromEndpoint registers the http handlers for service Network
func RegisterNetworkHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()
	return RegisterNetworkHandler(ctx, mux, conn)
}

// RegisterNetworkHandler registers the http handlers for service Network
func RegisterNetworkHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterNetworkHandlerClient(ctx, mux, NewNetworkClient(conn))
}

// RegisterNetworkHandlerClient registers the http handlers for service Network
func RegisterNetworkHandlerClient(ctx context.Context, mux *runtime.ServeMux, client NetworkClient) error {
	// Network service has no methods with HTTP bindings
	return nil
}

// RegisterScanServiceHandlerFromEndpoint registers the http handlers for service ScanService
func RegisterScanServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()
	return RegisterScanServiceHandler(ctx, mux, conn)
}

// RegisterScanServiceHandler registers the http handlers for service ScanService
func RegisterScanServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterScanServiceHandlerClient(ctx, mux, NewScanServiceClient(conn))
}

// RegisterScanServiceHandlerClient registers the http handlers for service ScanService
func RegisterScanServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ScanServiceClient) error {
	// Register all ScanService endpoints
	// This would include all the explorer API endpoints like:
	// - /api/system/homepage-bundle
	// - /api/account/list
	// - /api/token
	// etc.
	
	// Example for GetHomepageBundle
	mux.Handle("GET", pattern_ScanService_GetHomepageBundle_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ScanService_GetHomepageBundle_0(rctx, inboundMarshaler, client, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		forward_ScanService_GetHomepageBundle_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
	})

	// ... (register all other ScanService endpoints)

	return nil
}

// Pattern definitions for ScanService endpoints
var (
	pattern_ScanService_GetHomepageBundle_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "system", "homepage-bundle"}, ""))
	pattern_ScanService_GetNodeMap_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "nodemap"}, ""))
	pattern_ScanService_GetTop10_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "top10"}, ""))
	pattern_ScanService_ProxyRequest_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "system", "proxy"}, ""))
	pattern_ScanService_GetTokens_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "token"}, ""))
	pattern_ScanService_GetTokensOverview_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "tokens", "overview"}, ""))
	pattern_ScanService_GetLRC20Tokens_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "token_lrc20"}, ""))
	pattern_ScanService_GetTokenHolders_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "tokenholders"}, ""))
	pattern_ScanService_GetAccountList_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "account", "list"}, ""))
	pattern_ScanService_GetAccountResourceInfo_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "account", "resource"}, ""))
	pattern_ScanService_GetStatsOverview_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "stats", "overview"}, ""))
	pattern_ScanService_GetTags_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"external", "tag"}, ""))
	pattern_ScanService_GetBlocks_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "block"}, ""))
	pattern_ScanService_GetTransactions_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "transaction"}, ""))
	pattern_ScanService_Search_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"api", "search"}, ""))
	// ... (all other patterns)
)

// Forward response functions for ScanService endpoints
var (
	forward_ScanService_GetHomepageBundle_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetNodeMap_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTop10_0 = runtime.ForwardResponseMessage
	forward_ScanService_ProxyRequest_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTokens_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTokensOverview_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetLRC20Tokens_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTokenHolders_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetAccountList_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetAccountResourceInfo_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetStatsOverview_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTags_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetBlocks_0 = runtime.ForwardResponseMessage
	forward_ScanService_GetTransactions_0 = runtime.ForwardResponseMessage
	forward_ScanService_Search_0 = runtime.ForwardResponseMessage
	// ... (all other forward functions)
)